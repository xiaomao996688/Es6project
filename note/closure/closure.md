## 闭包
局部变量本来应该在函数退出的时候被解除引用,但如果局部变量被封闭在闭包形成的环境中,那么这个局部变量就能一直生存下去。
如果在将来需要收回这些变量，我们可以手动把这些变量设为null。<br>
闭包和内存泄露有关系的地方是,使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄露<br>
在IE浏览器中，由于BOM和DOM中的对象是使用C++以COM对象的方式实现的,而COM对象的垃圾收集机制采用引用计数策略。基于引用计数策略的垃圾回收机制中，如果俩个对象之间形成了循环引用，那么俩个对象都将无法被收回,但循环引用造成的内存泄露在本质上也不是闭包造成的。
```js
var func = function () {
	var a = 1;
	console.info(a);
}
func() // 这个函数执行完成后a=1就会被销毁掉
```
```js
var func = function () {
	var a = 1;
	return function () {
		a++
		console.log(a);
	}
}
//f 是这个return function函数的引用 f把这个函数保存在了被调用的时候。
var f = func()
f()//2
f()//3
```